#include "nmos/node_resources_thread.h"

#include "nmos/activation_mode.h"
#include "nmos/model.h"
#include "nmos/node_resource.h"
#include "nmos/node_resources.h"
#include "nmos/slog.h"
#include "nmos/thread_utils.h"
#include "nmos/transport.h"

namespace nmos
{
    namespace experimental
    {
        // insert a node resource, and sub-resources, according to the settings, and then wait for sender/receiver activations or shutdown
        void node_resources_thread(nmos::node_model& model, slog::base_gate& gate)
        {
            using web::json::value;
            using web::json::value_of;

            const auto seed_id = nmos::with_read_lock(model.mutex, [&] { return nmos::experimental::fields::seed_id(model.settings); });
            auto node_id = nmos::make_repeatable_id(seed_id, U("/x-nmos/node/self"));
            auto device_id = nmos::make_repeatable_id(seed_id, U("/x-nmos/node/device/0"));
            auto source_id = nmos::make_repeatable_id(seed_id, U("/x-nmos/node/source/0"));
            auto flow_id = nmos::make_repeatable_id(seed_id, U("/x-nmos/node/flow/0"));
            auto sender_id = nmos::make_repeatable_id(seed_id, U("/x-nmos/node/sender/0"));
            auto receiver_id = nmos::make_repeatable_id(seed_id, U("/x-nmos/node/receiver/0"));

            // should replace this with something generated by sdp::make_session_description
            const auto smpte2022_7_video_sdp = U(R"(v=0
o=- 2358175406662690538 2358175406662690538 IN IP4 192.168.9.142
s=Example Sender 1 (Video)
t=0 0
a=group:DUP PRIMARY SECONDARY
m=video 50020 RTP/AVP 96
c=IN IP4 239.22.142.1/32
a=ts-refclk:ptp=IEEE1588-2008:traceable
a=source-filter: incl IN IP4 239.22.142.1 192.168.9.142
a=rtpmap:96 raw/90000
a=fmtp:96 colorimetry=BT709; exactframerate=30000/1001; depth=10; TCS=SDR; sampling=YCbCr-4:2:2; width=1920; interlace; TP=2110TPN; PM=2110GPM; height=1080; SSN=ST2110-20:2017; 
a=mediaclk:direct=0
a=mid:PRIMARY
m=video 50120 RTP/AVP 96
c=IN IP4 239.122.142.1/32
a=ts-refclk:ptp=IEEE1588-2008:traceable
a=source-filter: incl IN IP4 239.122.142.1 192.168.109.142
a=rtpmap:96 raw/90000
a=fmtp:96 colorimetry=BT709; exactframerate=30000/1001; depth=10; TCS=SDR; sampling=YCbCr-4:2:2; width=1920; interlace; TP=2110TPN; PM=2110GPM; height=1080; SSN=ST2110-20:2017; 
a=mediaclk:direct=0
a=mid:SECONDARY
)");

            auto lock = model.write_lock(); // in order to update the resources

            // any delay between updates to the model resources is unnecessary
            // this just serves as a slightly more realistic example!
            const unsigned int delay_millis{ 50 };

            const auto insert_resource_after = [&](unsigned int milliseconds, nmos::resource&& resource, slog::base_gate& gate)
            {
                // using wait_until rather than wait_for as a workaround for an awful bug in VS2015, resolved in VS2017
                if (!model.shutdown_condition.wait_until(lock, std::chrono::steady_clock::now() + std::chrono::milliseconds(milliseconds), [&] { return model.shutdown; }))
                {
                    const std::pair<nmos::id, nmos::type> id_type{ resource.id, resource.type };
                    const bool success = insert_resource(model.node_resources, std::move(resource)).second;

                    if (success)
                        slog::log<slog::severities::info>(gate, SLOG_FLF) << "Updated model with " << id_type;
                    else
                        slog::log<slog::severities::severe>(gate, SLOG_FLF) << "Model update error: " << id_type;

                    if (nmos::types::sender == id_type.second) insert_resource(model.connection_resources, make_connection_sender(id_type.first, true, smpte2022_7_video_sdp));
                    else if (nmos::types::receiver == id_type.second) insert_resource(model.connection_resources, make_connection_receiver(id_type.first, true));

                    slog::log<slog::severities::too_much_info>(gate, SLOG_FLF) << "Notifying node behaviour thread"; // and anyone else who cares...
                    model.notify();
                }
            };

            insert_resource_after(delay_millis, make_node(node_id, model.settings), gate);
            insert_resource_after(delay_millis, make_device(device_id, node_id, { sender_id }, { receiver_id }, model.settings), gate);
            insert_resource_after(delay_millis, make_video_source(source_id, device_id, { 25, 1 }, model.settings), gate);
            insert_resource_after(delay_millis, make_raw_video_flow(flow_id, source_id, device_id, model.settings), gate);
            insert_resource_after(delay_millis, make_sender(sender_id, flow_id, device_id, {}, model.settings), gate);
            insert_resource_after(delay_millis, make_video_receiver(receiver_id, device_id, nmos::transports::rtp_mcast, {}, model.settings), gate);

            auto most_recent_update = tai_min();

            for (;;)
            {
                // wait for the thread to be interrupted because there may be immediate activations to process
                // or because the server is being shut down
                model.wait(lock, [&] { return model.shutdown || most_recent_update < nmos::most_recent_update(model.connection_resources); });
                if (model.shutdown) break;

                auto& by_updated = model.connection_resources.get<tags::updated>();
                const auto last = by_updated.lower_bound(most_recent_update);

                bool notify = false;

                for (auto resource = by_updated.begin(); last != resource; ++resource)
                {
                    auto& staged = nmos::fields::endpoint_staged(resource->data);
                    auto& staged_activation = nmos::fields::activation(staged);
                    auto& staged_mode = nmos::fields::mode(staged_activation);

                    if (!staged_mode.is_null() && nmos::activation_modes::activate_immediate.name == staged_mode.as_string())
                    {
                        slog::log<slog::severities::info>(gate, SLOG_FLF) << "Processing immediate activation";

                        const auto now = value::string(nmos::make_version());

                        bool active = false;
                        value connected_id;

                        // Update the IS-05 connection resource

                        nmos::modify_resource(model.connection_resources, resource->id, [&now, &active, &connected_id](nmos::resource& resource)
                        {
                            resource.data[nmos::fields::version] = now;

                            // This demonstrates a successful activation. When an activation is unsuccessful,
                            // make whatever changes are necessary to the active endpoint, and set the staged endpoint
                            // activation mode, requested_time, and activation_time, to null.

                            auto& staged = nmos::fields::endpoint_staged(resource.data);

                            active = nmos::fields::master_enable(staged);
                            // Senders indicate the connected receiver_id, receivers indicate the connected sender_id
                            connected_id = nmos::types::sender == resource.type ? nmos::fields::receiver_id(staged) : nmos::fields::sender_id(staged);

                            // Set the time of activation (will be included in the PATCH response)
                            staged[nmos::fields::activation][nmos::fields::activation_time] = now;

                            // "When a set of 'staged' settings is activated, these settings transition into the 'active' resource."
                            // See https://github.com/AMWA-TV/nmos-device-connection-management/blob/v1.0/docs/1.0.%20Overview.md#active
                            resource.data[nmos::fields::endpoint_active] = resource.data[nmos::fields::endpoint_staged];

                            // "On activation all instances of "auto" should be resolved into the actual values that will be used"
                            // See https://github.com/AMWA-TV/nmos-device-connection-management/blob/v1.0/APIs/ConnectionAPI.raml#L257
                            // and https://github.com/AMWA-TV/nmos-device-connection-management/blob/v1.0/docs/2.2.%20APIs%20-%20Server%20Side%20Implementation.md#use-of-auto
                            // Currently, left as an exercise...

                            // Unclear whether the activation in the active endpoint should have values for mode, requested_time
                            // (and even activation_time?) or whether they should be null? The examples have them with values.
                            // See https://github.com/AMWA-TV/nmos-device-connection-management/blob/v1.0/examples/v1.0-receiver-active-get-200.json
                            // and https://github.com/AMWA-TV/nmos-device-connection-management/blob/v1.0/examples/v1.0-sender-active-get-200.json
                        });

                        // Update the IS-04 resource

                        // "The UUIDs used to advertise Senders and Receivers in the Connection Management API must match
                        // those used in a corresponding IS-04 implementation."
                        // Luckily enough.
                        // See https://github.com/AMWA-TV/nmos-device-connection-management/blob/v1.0/docs/3.1.%20Interoperability%20-%20NMOS%20IS-04.md#sender--receiver-ids
                        nmos::modify_resource(model.node_resources, resource->id, [&now, &active, &connected_id](nmos::resource& resource)
                        {
                            // "When the 'active' parameters of a Sender or Receiver are modified, or when a re-activation of the same parameters
                            // is performed, the 'version' attribute of the relevant IS-04 Sender or Receiver must be incremented."
                            // See https://github.com/AMWA-TV/nmos-device-connection-management/blob/v1.0/docs/3.1.%20Interoperability%20-%20NMOS%20IS-04.md#version-increments
                            resource.data[nmos::fields::version] = now;

                            // Senders indicate the connected receiver_id, receivers indicate the connected sender_id
                            nmos::fields::subscription(resource.data) = value_of({
                                { nmos::fields::active, active },
                                { nmos::types::sender == resource.type ? nmos::fields::receiver_id : nmos::fields::sender_id, connected_id }
                            });
                        });

                        notify = true;
                    }
                }

                if (notify)
                {
                    slog::log<slog::severities::too_much_info>(gate, SLOG_FLF) << "Notifying node behaviour thread"; // and anyone else who cares...
                    model.notify();
                }

                most_recent_update = nmos::most_recent_update(model.connection_resources);
            }
        }
    }
}

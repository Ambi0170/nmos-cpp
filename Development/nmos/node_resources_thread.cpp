#include "nmos/node_resources_thread.h"

#include <boost/range/adaptor/reversed.hpp>
#include "nmos/activation_mode.h"
#include "nmos/connection_api.h"
#include "nmos/model.h"
#include "nmos/node_resource.h"
#include "nmos/node_resources.h"
#include "nmos/slog.h"
#include "nmos/thread_utils.h"
#include "nmos/transport.h"

namespace nmos
{
    namespace experimental
    {
        // insert a node resource, and sub-resources, according to the settings, and then wait for sender/receiver activations or shutdown
        void node_resources_thread(nmos::node_model& model, slog::base_gate& gate)
        {
            using web::json::value;
            using web::json::value_of;

            const auto seed_id = nmos::with_read_lock(model.mutex, [&] { return nmos::experimental::fields::seed_id(model.settings); });
            auto node_id = nmos::make_repeatable_id(seed_id, U("/x-nmos/node/self"));
            auto device_id = nmos::make_repeatable_id(seed_id, U("/x-nmos/node/device/0"));
            auto source_id = nmos::make_repeatable_id(seed_id, U("/x-nmos/node/source/0"));
            auto flow_id = nmos::make_repeatable_id(seed_id, U("/x-nmos/node/flow/0"));
            auto sender_id = nmos::make_repeatable_id(seed_id, U("/x-nmos/node/sender/0"));
            auto receiver_id = nmos::make_repeatable_id(seed_id, U("/x-nmos/node/receiver/0"));

            // should replace this with something generated by sdp::make_session_description
            const auto smpte2022_7_video_sdp = R"(v=0
o=- 16088568667046861078 16088568667046861078 IN IP4 192.168.9.142
s=Example Sender 1 (Video)
t=0 0
a=group:DUP PRIMARY SECONDARY
m=video 50020 RTP/AVP 96
c=IN IP4 239.22.142.1/32
a=ts-refclk:ptp=IEEE1588-2008:traceable
a=source-filter: incl IN IP4 239.22.142.1 192.168.9.142
a=rtpmap:96 raw/90000
a=fmtp:96 colorimetry=BT709; exactframerate=30000/1001; depth=10; TCS=SDR; sampling=YCbCr-4:2:2; width=1920; interlace; TP=2110TPN; PM=2110GPM; height=1080; SSN=ST2110-20:2017; 
a=mediaclk:direct=0
a=mid:PRIMARY
m=video 50120 RTP/AVP 96
c=IN IP4 239.122.142.1/32
a=ts-refclk:ptp=IEEE1588-2008:traceable
a=source-filter: incl IN IP4 239.122.142.1 192.168.109.142
a=rtpmap:96 raw/90000
a=fmtp:96 colorimetry=BT709; exactframerate=30000/1001; depth=10; TCS=SDR; sampling=YCbCr-4:2:2; width=1920; interlace; TP=2110TPN; PM=2110GPM; height=1080; SSN=ST2110-20:2017; 
a=mediaclk:direct=0
a=mid:SECONDARY
)";

            auto lock = model.write_lock(); // in order to update the resources

            // any delay between updates to the model resources is unnecessary
            // this just serves as a slightly more realistic example!
            const unsigned int delay_millis{ 50 };

            const auto insert_resource_after = [&](unsigned int milliseconds, nmos::resource&& resource, slog::base_gate& gate)
            {
                if (!nmos::details::wait_for(model.shutdown_condition, lock, std::chrono::milliseconds(milliseconds), [&] { return model.shutdown; }))
                {
                    const std::pair<nmos::id, nmos::type> id_type{ resource.id, resource.type };
                    const bool success = insert_resource(model.node_resources, std::move(resource)).second;

                    if (success)
                        slog::log<slog::severities::info>(gate, SLOG_FLF) << "Updated model with " << id_type;
                    else
                        slog::log<slog::severities::severe>(gate, SLOG_FLF) << "Model update error: " << id_type;

                    if (nmos::types::sender == id_type.second) insert_resource(model.connection_resources, make_connection_sender(id_type.first, true, utility::s2us(smpte2022_7_video_sdp)));
                    else if (nmos::types::receiver == id_type.second) insert_resource(model.connection_resources, make_connection_receiver(id_type.first, true));

                    slog::log<slog::severities::too_much_info>(gate, SLOG_FLF) << "Notifying node behaviour thread"; // and anyone else who cares...
                    model.notify();
                }
            };

            {
                // for now, just add one example network interface
                auto node = make_node(node_id, model.settings);
                node.data[U("interfaces")] = value_of({ value_of({ { U("chassis_id"), value::null() }, { U("port_id"), U("ff-ff-ff-ff-ff-ff") }, { U("name"), U("example") } }) });
                insert_resource_after(delay_millis, std::move(node), gate);
            }
            insert_resource_after(delay_millis, make_device(device_id, node_id, { sender_id }, { receiver_id }, model.settings), gate);
            insert_resource_after(delay_millis, make_video_source(source_id, device_id, { 25, 1 }, model.settings), gate);
            insert_resource_after(delay_millis, make_raw_video_flow(flow_id, source_id, device_id, model.settings), gate);
            insert_resource_after(delay_millis, make_sender(sender_id, flow_id, device_id, { U("example"), U("example") }, model.settings), gate);
            insert_resource_after(delay_millis, make_video_receiver(receiver_id, device_id, nmos::transports::rtp_mcast, { U("example"), U("example") }, model.settings), gate);

            auto most_recent_update = tai_min();
            auto earliest_scheduled_activation = (tai_clock::time_point::max)();

            for (;;)
            {
                // wait for the thread to be interrupted because there may be new scheduled activations, or immediate activations to process
                // or because the server is being shut down
                // or because it's time for the next scheduled activation
                model.wait_until(lock, earliest_scheduled_activation, [&] { return model.shutdown || most_recent_update < nmos::most_recent_update(model.connection_resources); });
                if (model.shutdown) break;

                auto& by_updated = model.connection_resources.get<nmos::tags::updated>();

                // go through all connection resources
                // process any immediate activations
                // process any scheduled activations whose requested_time has passed
                // identify the next scheduled activation

                const auto now = tai_clock::now();

                earliest_scheduled_activation = (tai_clock::time_point::max)();

                bool notify = false;

                for (const auto& resource : by_updated | boost::adaptors::reversed)
                {
                    if (!resource.has_data()) continue;

                    const std::pair<nmos::id, nmos::type> id_type{ resource.id, resource.type };

                    auto& staged = nmos::fields::endpoint_staged(resource.data);
                    auto& staged_activation = nmos::fields::activation(staged);
                    auto& staged_mode_or_null = nmos::fields::mode(staged_activation);

                    if (staged_mode_or_null.is_null()) continue;

                    const nmos::activation_mode staged_mode{ staged_mode_or_null.as_string() };

                    if (nmos::activation_modes::activate_scheduled_absolute == staged_mode ||
                        nmos::activation_modes::activate_scheduled_relative == staged_mode)
                    {
                        auto& staged_activation_time = nmos::fields::activation_time(staged_activation);
                        const auto scheduled_activation = nmos::time_point_from_tai(nmos::parse_version(staged_activation_time.as_string()));

                        if (scheduled_activation < now)
                        {
                            slog::log<slog::severities::info>(gate, SLOG_FLF) << "Processing scheduled activation for " << id_type;
                        }
                        else
                        {
                            if (scheduled_activation < earliest_scheduled_activation)
                            {
                                earliest_scheduled_activation = scheduled_activation;
                            }

                            continue;
                        }
                    }
                    else if (nmos::activation_modes::activate_immediate == staged_mode)
                    {
                        // check for cancelled in-flight immediate activation
                        if (nmos::fields::requested_time(staged_activation).is_null()) continue;
                        // check for processed in-flight immediate activation
                        if (!nmos::fields::activation_time(staged_activation).is_null()) continue;

                        slog::log<slog::severities::info>(gate, SLOG_FLF) << "Processing immediate activation for " << id_type;
                    }
                    else
                    {
                        slog::log<slog::severities::severe>(gate, SLOG_FLF) << "Unexpected activation mode for " << id_type;
                        continue;
                    }

                    const auto activation_time = tai_now();

                    bool active = false;
                    nmos::id connected_id;

                    // Update the IS-05 connection resource

                    nmos::modify_resource(model.connection_resources, resource.id, [&activation_time, &active, &connected_id](nmos::resource& resource)
                    {
                        nmos::set_connection_resource_active(resource, [&resource](web::json::value& endpoint_active)
                        {
                            // "In some cases the behaviour is more complex, and may be determined by the vendor."
                            // See https://github.com/AMWA-TV/nmos-device-connection-management/blob/v1.0/docs/2.2.%20APIs%20-%20Server%20Side%20Implementation.md#use-of-auto
                            // E.g. sender "source_ip" and receiver "interface_ip" currently left as an exercise...

                            nmos::resolve_auto(resource.type, endpoint_active[nmos::fields::transport_params]);
                        }, activation_time);

                        auto& endpoint_active = nmos::fields::endpoint_active(resource.data);
                        active = nmos::fields::master_enable(endpoint_active);
                        // Senders indicate the connected receiver_id, receivers indicate the connected sender_id
                        auto& connected_id_or_null = nmos::types::sender == resource.type ? nmos::fields::receiver_id(endpoint_active) : nmos::fields::sender_id(endpoint_active);
                        if (!connected_id_or_null.is_null()) connected_id = connected_id_or_null.as_string();
                    });

                    // Update the IS-04 resource

                    nmos::modify_resource(model.node_resources, resource.id, [&activation_time, &active, &connected_id](nmos::resource& resource)
                    {
                        nmos::set_resource_subscription(resource, active, connected_id, activation_time);
                    });

                    notify = true;
                }

                if ((tai_clock::time_point::max)() != earliest_scheduled_activation)
                {
                    slog::log<slog::severities::more_info>(gate, SLOG_FLF) << "Next scheduled activation is at " << nmos::make_version(nmos::tai_from_time_point(earliest_scheduled_activation))
                        << " in about " << std::fixed << std::setprecision(3) << std::chrono::duration_cast<std::chrono::duration<double>>(earliest_scheduled_activation - now).count() << " seconds time";
                }

                if (notify)
                {
                    slog::log<slog::severities::too_much_info>(gate, SLOG_FLF) << "Notifying node behaviour thread"; // and anyone else who cares...
                    model.notify();
                }

                most_recent_update = nmos::most_recent_update(model.connection_resources);
            }
        }
    }
}

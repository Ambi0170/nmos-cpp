#include "nmos/node_resources_thread.h"

#include <boost/range/adaptor/reversed.hpp>
#include "nmos/activation_mode.h"
#include "nmos/model.h"
#include "nmos/node_resource.h"
#include "nmos/node_resources.h"
#include "nmos/slog.h"
#include "nmos/thread_utils.h"
#include "nmos/transport.h"

namespace nmos
{
    namespace experimental
    {
        // insert a node resource, and sub-resources, according to the settings, and then wait for sender/receiver activations or shutdown
        void node_resources_thread(nmos::node_model& model, slog::base_gate& gate)
        {
            using web::json::value;
            using web::json::value_of;

            const auto seed_id = nmos::with_read_lock(model.mutex, [&] { return nmos::experimental::fields::seed_id(model.settings); });
            auto node_id = nmos::make_repeatable_id(seed_id, U("/x-nmos/node/self"));
            auto device_id = nmos::make_repeatable_id(seed_id, U("/x-nmos/node/device/0"));
            auto source_id = nmos::make_repeatable_id(seed_id, U("/x-nmos/node/source/0"));
            auto flow_id = nmos::make_repeatable_id(seed_id, U("/x-nmos/node/flow/0"));
            auto sender_id = nmos::make_repeatable_id(seed_id, U("/x-nmos/node/sender/0"));
            auto receiver_id = nmos::make_repeatable_id(seed_id, U("/x-nmos/node/receiver/0"));

            // should replace this with something generated by sdp::make_session_description
            const auto smpte2022_7_video_sdp = U(R"(v=0
o=- 2358175406662690538 2358175406662690538 IN IP4 192.168.9.142
s=Example Sender 1 (Video)
t=0 0
a=group:DUP PRIMARY SECONDARY
m=video 50020 RTP/AVP 96
c=IN IP4 239.22.142.1/32
a=ts-refclk:ptp=IEEE1588-2008:traceable
a=source-filter: incl IN IP4 239.22.142.1 192.168.9.142
a=rtpmap:96 raw/90000
a=fmtp:96 colorimetry=BT709; exactframerate=30000/1001; depth=10; TCS=SDR; sampling=YCbCr-4:2:2; width=1920; interlace; TP=2110TPN; PM=2110GPM; height=1080; SSN=ST2110-20:2017; 
a=mediaclk:direct=0
a=mid:PRIMARY
m=video 50120 RTP/AVP 96
c=IN IP4 239.122.142.1/32
a=ts-refclk:ptp=IEEE1588-2008:traceable
a=source-filter: incl IN IP4 239.122.142.1 192.168.109.142
a=rtpmap:96 raw/90000
a=fmtp:96 colorimetry=BT709; exactframerate=30000/1001; depth=10; TCS=SDR; sampling=YCbCr-4:2:2; width=1920; interlace; TP=2110TPN; PM=2110GPM; height=1080; SSN=ST2110-20:2017; 
a=mediaclk:direct=0
a=mid:SECONDARY
)");

            auto lock = model.write_lock(); // in order to update the resources

            // any delay between updates to the model resources is unnecessary
            // this just serves as a slightly more realistic example!
            const unsigned int delay_millis{ 50 };

            const auto insert_resource_after = [&](unsigned int milliseconds, nmos::resource&& resource, slog::base_gate& gate)
            {
                // using wait_until rather than wait_for as a workaround for an awful bug in VS2015, resolved in VS2017
                if (!model.shutdown_condition.wait_until(lock, std::chrono::steady_clock::now() + std::chrono::milliseconds(milliseconds), [&] { return model.shutdown; }))
                {
                    const std::pair<nmos::id, nmos::type> id_type{ resource.id, resource.type };
                    const bool success = insert_resource(model.node_resources, std::move(resource)).second;

                    if (success)
                        slog::log<slog::severities::info>(gate, SLOG_FLF) << "Updated model with " << id_type;
                    else
                        slog::log<slog::severities::severe>(gate, SLOG_FLF) << "Model update error: " << id_type;

                    if (nmos::types::sender == id_type.second) insert_resource(model.connection_resources, make_connection_sender(id_type.first, true, smpte2022_7_video_sdp));
                    else if (nmos::types::receiver == id_type.second) insert_resource(model.connection_resources, make_connection_receiver(id_type.first, true));

                    slog::log<slog::severities::too_much_info>(gate, SLOG_FLF) << "Notifying node behaviour thread"; // and anyone else who cares...
                    model.notify();
                }
            };

            insert_resource_after(delay_millis, make_node(node_id, model.settings), gate);
            insert_resource_after(delay_millis, make_device(device_id, node_id, { sender_id }, { receiver_id }, model.settings), gate);
            insert_resource_after(delay_millis, make_video_source(source_id, device_id, { 25, 1 }, model.settings), gate);
            insert_resource_after(delay_millis, make_raw_video_flow(flow_id, source_id, device_id, model.settings), gate);
            insert_resource_after(delay_millis, make_sender(sender_id, flow_id, device_id, {}, model.settings), gate);
            insert_resource_after(delay_millis, make_video_receiver(receiver_id, device_id, nmos::transports::rtp_mcast, {}, model.settings), gate);

            auto most_recent_update = tai_min();
            auto earliest_scheduled_activation = (tai_clock::time_point::max)();

            for (;;)
            {
                // wait for the thread to be interrupted because there may be new scheduled activations, or immediate activations to process
                // or because the server is being shut down
                // or because it's time for the next scheduled activation
                model.wait_until(lock, earliest_scheduled_activation, [&] { return model.shutdown || most_recent_update < nmos::most_recent_update(model.connection_resources); });
                if (model.shutdown) break;

                auto& by_updated = model.connection_resources.get<nmos::tags::updated>();

                // go through all connection resources
                // process any immediate activations
                // process any scheduled activations whose requested_time has passed
                // identify the next scheduled activation

                const auto now = tai_clock::now();

                earliest_scheduled_activation = (tai_clock::time_point::max)();

                bool notify = false;

                for (auto& resource : by_updated | boost::adaptors::reversed)
                {
                    const std::pair<nmos::id, nmos::type> id_type{ resource.id, resource.type };

                    auto& staged = nmos::fields::endpoint_staged(resource.data);
                    auto& staged_activation = nmos::fields::activation(staged);
                    auto& staged_mode_or_null = nmos::fields::mode(staged_activation);

                    if (staged_mode_or_null.is_null()) continue;

                    const nmos::activation_mode staged_mode{ staged_mode_or_null.as_string() };

                    if (nmos::activation_modes::activate_scheduled_absolute == staged_mode ||
                        nmos::activation_modes::activate_scheduled_relative == staged_mode)
                    {
                        auto& staged_activation_time = nmos::fields::activation_time(staged_activation);
                        const auto scheduled_activation = nmos::time_point_from_tai(nmos::parse_version(staged_activation_time.as_string()));

                        if (scheduled_activation < now)
                        {
                            slog::log<slog::severities::info>(gate, SLOG_FLF) << "Processing scheduled activation for " << id_type;
                        }
                        else
                        {
                            if (scheduled_activation < earliest_scheduled_activation)
                            {
                                earliest_scheduled_activation = scheduled_activation;
                            }

                            continue;
                        }
                    }
                    else if (nmos::activation_modes::activate_immediate == staged_mode)
                    {
                        // check for cancelled in-flight immediate activation
                        if (nmos::fields::requested_time(staged_activation).is_null()) continue;
                        // check for processed in-flight immediate activation
                        if (!nmos::fields::activation_time(staged_activation).is_null()) continue;

                        slog::log<slog::severities::info>(gate, SLOG_FLF) << "Processing immediate activation for " << id_type;
                    }
                    else
                    {
                        slog::log<slog::severities::severe>(gate, SLOG_FLF) << "Unexpected activation mode for " << id_type;
                        continue;
                    }

                    const auto right_now = value::string(nmos::make_version());

                    bool active = false;
                    value connected_id;

                    // Update the IS-05 connection resource

                    // hmm, this could be extracted as a function, e.g. activate_connection_resource(resources&, const id&, const tai& = tai_now())
                    // it'd also need a function argument to resolve "auto" values in the staged settings
                    // it'd return the boolean result, and for use here, ideally also have two output variables (bool active, value connected_id_or_null)
                    nmos::modify_resource(model.connection_resources, resource.id, [&right_now, &active, &connected_id](nmos::resource& resource)
                    {
                        resource.data[nmos::fields::version] = right_now;

                        // This demonstrates a successful activation. When an activation is unsuccessful,
                        // make whatever changes are necessary to the active endpoint, and set the staged endpoint
                        // activation mode, requested_time, and activation_time, to null.

                        auto& staged = nmos::fields::endpoint_staged(resource.data);
                        auto& staged_activation = staged[nmos::fields::activation];
                        const nmos::activation_mode staged_mode{ nmos::fields::mode(staged_activation).as_string() };

                        active = nmos::fields::master_enable(staged);
                        // Senders indicate the connected receiver_id, receivers indicate the connected sender_id
                        connected_id = nmos::types::sender == resource.type ? nmos::fields::receiver_id(staged) : nmos::fields::sender_id(staged);

                        // Set the time of activation (will be included in the PATCH response for an immediate activation)
                        staged_activation[nmos::fields::activation_time] = right_now;

                        // "When a set of 'staged' settings is activated, these settings transition into the 'active' resource."
                        // See https://github.com/AMWA-TV/nmos-device-connection-management/blob/v1.0/docs/1.0.%20Overview.md#active
                        resource.data[nmos::fields::endpoint_active] = resource.data[nmos::fields::endpoint_staged];

                        // "On activation all instances of "auto" should be resolved into the actual values that will be used"
                        // See https://github.com/AMWA-TV/nmos-device-connection-management/blob/v1.0/APIs/ConnectionAPI.raml#L257
                        // and https://github.com/AMWA-TV/nmos-device-connection-management/blob/v1.0/docs/2.2.%20APIs%20-%20Server%20Side%20Implementation.md#use-of-auto
                        // Currently, left as an exercise...

                        // Unclear whether the activation in the active endpoint should have values for mode, requested_time
                        // (and even activation_time?) or whether they should be null? The examples have them with values.
                        // See https://github.com/AMWA-TV/nmos-device-connection-management/blob/v1.0/examples/v1.0-receiver-active-get-200.json
                        // and https://github.com/AMWA-TV/nmos-device-connection-management/blob/v1.0/examples/v1.0-sender-active-get-200.json

                        if (nmos::activation_modes::activate_scheduled_absolute == staged_mode ||
                            nmos::activation_modes::activate_scheduled_relative == staged_mode)
                        {
                            // "This parameter returns to null on the staged endpoint once an activation is completed."
                            // "This field returns to null once the activation is completed on the staged endpoint."
                            // "On the staged endpoint this field returns to null once the activation is completed."
                            // See https://github.com/AMWA-TV/nmos-device-connection-management/blob/v1.0/APIs/schemas/v1.0-activation-response-schema.json
                            staged_activation = value_of({
                                { nmos::fields::mode, value::null() },
                                { nmos::fields::requested_time, value::null() },
                                { nmos::fields::activation_time, value::null() }
                            });
                        }
                    });

                    // Update the IS-04 resource

                    // "The UUIDs used to advertise Senders and Receivers in the Connection Management API must match
                    // those used in a corresponding IS-04 implementation."
                    // Luckily enough.
                    // See https://github.com/AMWA-TV/nmos-device-connection-management/blob/v1.0/docs/3.1.%20Interoperability%20-%20NMOS%20IS-04.md#sender--receiver-ids

                    // hmm, this could be extracted as a function, e.g. modify_resource_subscription(resources&, id&, bool, value&, const tai& = tai_now())
                    // it'd return the boolean result
                    nmos::modify_resource(model.node_resources, resource.id, [&right_now, &active, &connected_id](nmos::resource& resource)
                    {
                        // "When the 'active' parameters of a Sender or Receiver are modified, or when a re-activation of the same parameters
                        // is performed, the 'version' attribute of the relevant IS-04 Sender or Receiver must be incremented."
                        // See https://github.com/AMWA-TV/nmos-device-connection-management/blob/v1.0/docs/3.1.%20Interoperability%20-%20NMOS%20IS-04.md#version-increments
                        resource.data[nmos::fields::version] = right_now;

                        // Senders indicate the connected receiver_id, receivers indicate the connected sender_id
                        // (depending on the API version)
                        if (nmos::is04_versions::v1_2 <= resource.version)
                        {
                            nmos::fields::subscription(resource.data) = value_of({
                                { nmos::fields::active, active },
                                { nmos::types::sender == resource.type ? nmos::fields::receiver_id : nmos::fields::sender_id, connected_id }
                            });
                        }
                        else if (nmos::types::receiver == resource.type)
                        {
                            nmos::fields::subscription(resource.data) = value_of({
                                { nmos::fields::sender_id, connected_id }
                            });
                        }
                    });

                    notify = true;
                }

                if (notify)
                {
                    slog::log<slog::severities::too_much_info>(gate, SLOG_FLF) << "Notifying node behaviour thread"; // and anyone else who cares...
                    model.notify();
                }

                most_recent_update = nmos::most_recent_update(model.connection_resources);
            }
        }
    }
}

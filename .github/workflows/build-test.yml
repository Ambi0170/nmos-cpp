name: 'build-test'

on: [pull_request, push]

# secrets:
#  * GOOGLE_CREDENTIALS - base64 encoded google service account credentials, must be a single line with no whitespace
#  * BONJOUR_DRIVE_ID - google drive id of windows bonjour installer (Bonjour64.msi)
#  * OUTPUT_FOLDER_ID - google drive id of folder to upload build results to
#  * RESULTS_SHEET_ID - google sheets id of sheet to upload results to
jobs:
  build_and_test:
    name: '${{ matrix.os }}: build and test (install mdns: ${{ matrix.install_mdns }})'
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        install_mdns: [false]
        include:
          - install_mdns: true
            os: ubuntu-latest

    steps:
    - uses: actions/checkout@v2

    - name: set environment variables
      shell: bash
      run: |
        if [[ "${{ matrix.os }}"  == "ubuntu-latest" ]]; then
          if [[ "${{ matrix.install_mdns }}" == "true" ]]; then
            echo "::set-env name=BUILD_NAME::${{ matrix.os }}_mdns"
          else
            echo "::set-env name=BUILD_NAME::${{ matrix.os }}_avahi"
          fi
        else
          echo "::set-env name=BUILD_NAME::${{ matrix.os }}"
        fi
        GITHUB_COMMIT=`echo "${{ github.sha }}" | cut -c1-7`
        echo "::set-env name=GITHUB_COMMIT::$GITHUB_COMMIT"

    - name: setup google drive
      run: |
        mkdir ${{ github.workspace }}/gdrive
        echo "${{ env.credentials }}" | openssl base64 -d -A -out ${{ github.workspace }}/gdrive/credentials.json
      env:
        credentials: ${{ secrets.GOOGLE_CREDENTIALS }}

    - name: download google drive windows
      if: matrix.os =='windows-latest'
      shell: bash
      working-directory: ${{ github.workspace }}/gdrive
      run: |
        curl -L https://github.com/gdrive-org/gdrive/releases/download/2.1.0/gdrive-windows-x64.exe -o gdrive-windows-x64.exe -q
        echo "::set-env name=GDRIVE_PATH::`pwd`/gdrive-windows-x64.exe --config `pwd` --service-account credentials.json"
        echo "::set-env name=GDRIVE_GET_ID::`pwd`/../Sandbox/get_gdrive_id.sh"
        echo "::set-env name=GDRIVE_CREDENTIALS::`pwd`/credentials.json"

    - name: download google drive mac
      if: matrix.os =='macos-latest'
      run: |
        curl -L https://github.com/gdrive-org/gdrive/releases/download/2.1.0/gdrive-osx-x64 -o ${{ github.workspace }}/gdrive/gdrive-osx-x64 -q
        chmod +x ${{ github.workspace }}/gdrive/gdrive-osx-x64
        echo "::set-env name=GDRIVE_PATH::${{ github.workspace }}/gdrive/gdrive-osx-x64" --config ${{ github.workspace }}/gdrive --service-account credentials.json
        echo "::set-env name=GDRIVE_GET_ID::${{ github.workspace }}/Sandbox/get_gdrive_id.sh"
        echo "::set-env name=GDRIVE_CREDENTIALS::${{ github.workspace }}/gdrive/credentials.json"

    - name: download google drive ubuntu
      if: matrix.os =='ubuntu-latest'
      run: |
        curl -L https://github.com/gdrive-org/gdrive/releases/download/2.1.0/gdrive-linux-x64 -o ${{ github.workspace }}/gdrive/gdrive-linux-x64 -q
        chmod +x ${{ github.workspace }}/gdrive/gdrive-linux-x64
        echo "::set-env name=GDRIVE_PATH::${{ github.workspace }}/gdrive/gdrive-linux-x64" --config ${{ github.workspace }}/gdrive --service-account credentials.json
        echo "::set-env name=GDRIVE_GET_ID::${{ github.workspace }}/Sandbox/get_gdrive_id.sh"
        echo "::set-env name=GDRIVE_CREDENTIALS::${{ github.workspace }}/gdrive/credentials.json"

    - name: install python
      uses: actions/setup-python@v1
      with:
        python-version: 3.8

    - name: install pip and conan
      run: |
        python -m pip install --upgrade pip
        pip install conan

    - name: install cmake
      uses: lukka/get-cmake@v3.17.1

    - name: windows setup
      if: matrix.os =='windows-latest'
      run: |
        echo "::set-env name=CMAKE_EXTRA_ARGS::$CMAKE_EXTRA_ARGS -DNMOS_CPP_CONAN_BUILD_LIBS=cpprestsdk;missing -DCMAKE_C_COMPILER=cl.exe -DCMAKE_CXX_COMPILER=cl.exe"
        & "${{ github.workspace }}/gdrive/gdrive-windows-x64.exe" --config ${{ github.workspace }}/gdrive --service-account credentials.json download --path ${{ github.workspace }} ${{ env.bonjourid }}
        msiexec /i ${{ github.workspace }}\Bonjour64.msi /qn /norestart
        netsh interface set interface name="vEthernet (nat)" admin=DISABLED
        $env:hostip = (
          Get-NetIPConfiguration |
          Where-Object {
              $_.IPv4DefaultGateway -ne $null -and
              $_.NetAdapter.Status -ne "Disconnected"
          }
        ).IPv4Address.IPAddress
        echo "::set-env name=HOST_IP_ADDRESS::$env:hostip"
        ipconfig
      env:
        bonjourid: ${{ secrets.BONJOUR_DRIVE_ID }}

    - name: mac setup
      if: matrix.os =='macos-latest'
      run: |
        echo "::set-env name=CMAKE_EXTRA_ARGS::$CMAKE_EXTRA_ARGS '-DNMOS_CPP_CONAN_BUILD_LIBS=cpprestsdk;missing'"
        hostip=$(ipconfig getifaddr en0)
        echo "::set-env name=HOST_IP_ADDRESS::$hostip"
        ifconfig

    - name: mac docker install
      if: false
      run: |
        brew install docker docker-compose docker-machine xhyve docker-machine-driver-xhyve
        sudo chown root:wheel $(brew --prefix)/opt/docker-machine-driver-xhyve/bin/docker-machine-driver-xhyve
        sudo chmod u+s $(brew --prefix)/opt/docker-machine-driver-xhyve/bin/docker-machine-driver-xhyve
        mkdir -p /Users/runner/.docker/machine/cache/
        curl -Lo ~/.docker/machine/cache/boot2docker.iso https://github.com/boot2docker/boot2docker/releases/download/v19.03.5/boot2docker.iso
        i=0
        while ! docker-machine "--github-api-token=${{ secrets.GITHUB_TOKEN }}" create default --driver xhyve; do
          docker-machine rm -f default
          sleep 1
          $(( i++ ))
          if [[ $i -gt 5 ]]; then
            exit 1
          fi
        done
        eval $(docker-machine env default)
        echo "::set-env name=DOCKER_MACHINE_NAME::$DOCKER_MACHINE_NAME"
        echo "::set-env name=DOCKER_TLS_VERIFY::$DOCKER_TLS_VERIFY"
        echo "::set-env name=DOCKER_HOST::$DOCKER_HOST"
        echo "::set-env name=DOCKER_CERT_PATH::$DOCKER_CERT_PATH"


    - name: ubuntu setup
      if: matrix.os =='ubuntu-latest'
      run: |
        sudo ip addr flush dev docker0
        hostip=$(hostname -I | cut -f1 -d' ')
        echo "::set-env name=HOST_IP_ADDRESS::$hostip"
        ip address

    - name: ubuntu mdns install
      if: matrix.os =='ubuntu-latest' && matrix.install_mdns == true
      run: |
        cd ${{ github.workspace }}
        curl https://opensource.apple.com/tarballs/mDNSResponder/mDNSResponder-878.200.35.tar.gz -o mDNSResponder-878.200.35.tar.gz
        tar -xzf mDNSResponder-878.200.35.tar.gz
        patch -d mDNSResponder-878.200.35/ -p1 < ${{ github.workspace }}/Development/third_party/mDNSResponder/unicast.patch
        patch -d mDNSResponder-878.200.35/ -p1 < ${{ github.workspace }}/Development/third_party/mDNSResponder/permit-over-long-service-types.patch
        patch -d mDNSResponder-878.200.35/ -p1 < ${{ github.workspace }}/Development/third_party/mDNSResponder/poll-rather-than-select.patch
        cd mDNSResponder-878.200.35/mDNSPosix
        make os=linux && sudo make os=linux install

    - name: ubuntu avahi setup
      if: matrix.os =='ubuntu-latest' && matrix.install_mdns == false
      run: |
        sudo apt-get install -f libavahi-compat-libdnssd-dev
        echo "::set-env name=CTEST_EXTRA_ARGS::$CTEST_EXTRA_ARGS -E testMdnsAdvertiseAddress"
        sudo sed -i 's/#*allow-interfaces=.*/allow-interfaces=eth0/g' /etc/avahi/avahi-daemon.conf
        sudo systemctl restart avahi-daemon

    - uses: ilammy/msvc-dev-cmd@v1
    - name: build
      uses: lukka/run-cmake@v2.0
      with:
        cmakeListsOrSettingsJson: CMakeListsTxtAdvanced
        cmakeListsTxtPath: '${{ github.workspace }}/Development/CMakeLists.txt'
        buildDirectory: '${{ runner.workspace }}/build/'
        cmakeAppendedArgs: '-GNinja -DCMAKE_BUILD_TYPE=Release ${{ env.CMAKE_EXTRA_ARGS }}'

    - name: unit test
      run: |
        cd ${{ runner.workspace }}/build/
        ctest --output-on-failure ${{ env.CTEST_EXTRA_ARGS }}

    - name: AMWA test suite
      shell: bash
      working-directory: ${{ runner.workspace }}
      run:
        |
        set -x
        root_dir=`pwd`
        # Install AMWA test suite.
        git clone https://github.com/AMWA-TV/nmos-testing.git
        cd nmos-testing

        # Create output directories
        mkdir results
        mkdir badges

        if [[ "${{ env.DOCKER_TEST_SUITE }}" == "true" ]]; then
          docker pull amwa/nmos-testing
          docker run -d --name "nmos_testing" --entrypoint="/usr/bin/tail" -v `pwd`/results:/home/nmos-testing/results amwa/nmos-testing -f /dev/null
          run_test="docker exec -i nmos_testing python3 nmos-test.py"
        elif  [[ "${{ env.VAGRANT_TEST_SUITE }}" == "true" ]]; then
          cp ${{ github.workspace }}/.github/workflows/mac_Vagrantfile ./Vagrantfile
          vagrant plugin install vagrant-scp
          vagrant up
          vagrant ssh -- mkdir results
          run_test="vagrant ssh -- python3 nmos-test.py"
        else
          pip install -r requirements.txt

          # Install SDPoker
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            npm install -g AMWA-TV/sdpoker
          else
            sudo npm install -g AMWA-TV/sdpoker
          fi
          run_test="python nmos-test.py"
        fi
        pip install -r utilities/run-test-suites/gsheetsImport/requirements.txt

        ${root_dir}/build/nmos-cpp-node "{\"http_port\":1080,\"domain\":\"local.\",\"logging_level\":-40}" > results/nodeoutput 2>&1 &
        NODE_PID=$!

        # IS-04-01
        case $($run_test suite IS-04-01 --selection all --host "${{ env.HOST_IP_ADDRESS }}" --port 1080 --version v1.3 --output "results/${{ env.GITHUB_COMMIT }}-${{ env.BUILD_NAME }}-IS-04-01.json" >> results/testoutput 2>&1; echo $?) in
        [0-1])  testmessage="Pass" && testcolour="brightgreen";;
        *)      testmessage="Fail" && testcolour="red";;
        esac
        printf "{\"schemaVersion\":1,\"label\":\"IS-04-01\",\"message\":\"$testmessage\",\"color\":\"$testcolour\"}" > badges/IS-04-01.json

        # IS-04-03
        case $($run_test suite IS-04-03 --selection all --host "${{ env.HOST_IP_ADDRESS }}" --port 1080 --version v1.3 --output "results/${{ env.GITHUB_COMMIT }}-${{ env.BUILD_NAME }}-IS-04-03.json"  >> results/testoutput 2>&1; echo $?) in
        [0-1])  testmessage="Pass" && testcolour="brightgreen";;
        *)      testmessage="Fail" && testcolour="red";;
        esac
        printf "{\"schemaVersion\":1,\"label\":\"IS-04-03\",\"message\":\"$testmessage\",\"color\":\"$testcolour\"}" > badges/IS-04-03.json

        # IS-05-01
        case $($run_test suite IS-05-01 --selection all --host "${{ env.HOST_IP_ADDRESS }}" --port 1080 --version v1.1 --output "results/${{ env.GITHUB_COMMIT }}-${{ env.BUILD_NAME }}-IS-05-01.json"  >> results/testoutput 2>&1; echo $?) in
        [0-1])  testmessage="Pass" && testcolour="brightgreen";;
        *)      testmessage="Fail" && testcolour="red";;
        esac
        printf "{\"schemaVersion\":1,\"label\":\"IS-05-01\",\"message\":\"$testmessage\",\"color\":\"$testcolour\"}" > badges/IS-05-01.json

        # IS-05-02
        case $($run_test suite IS-05-02 --selection all --host "${{ env.HOST_IP_ADDRESS }}" "${{ env.HOST_IP_ADDRESS }}" --port 1080 1080 --version v1.3 v1.1 --output "results/${{ env.GITHUB_COMMIT }}-${{ env.BUILD_NAME }}-IS-05-02.json"  >> results/testoutput 2>&1; echo $?) in
        [0-1])  testmessage="Pass" && testcolour="brightgreen";;
        *)      testmessage="Fail" && testcolour="red";;
        esac
        printf "{\"schemaVersion\":1,\"label\":\"IS-05-02\",\"message\":\"$testmessage\",\"color\":\"$testcolour\"}" > badges/IS-05-02.json

        # IS-07-01
        case $($run_test suite IS-07-01 --selection all --host "${{ env.HOST_IP_ADDRESS }}" --port 1080 --version v1.0 --output "results/${{ env.GITHUB_COMMIT }}-${{ env.BUILD_NAME }}-IS-07-01.json"  >> results/testoutput 2>&1; echo $?) in
        [0-1])  testmessage="Pass" && testcolour="brightgreen";;
        *)      testmessage="Fail" && testcolour="red";;
        esac
        printf "{\"schemaVersion\":1,\"label\":\"IS-07-01\",\"message\":\"$testmessage\",\"color\":\"$testcolour\"}" > badges/IS-07-01.json

        # IS-07-02
        case $($run_test suite IS-07-02 --selection all --host "${{ env.HOST_IP_ADDRESS }}" "${{ env.HOST_IP_ADDRESS }}" "${{ env.HOST_IP_ADDRESS }}" --port 1080 1080 1080 --version v1.3 v1.1 v1.0 --output "results/${{ env.GITHUB_COMMIT }}-${{ env.BUILD_NAME }}-IS-07-02.json"  >> results/testoutput 2>&1; echo $?) in
        [0-1])  testmessage="Pass" && testcolour="brightgreen";;
        *)      testmessage="Fail" && testcolour="red";;
        esac
        printf "{\"schemaVersion\":1,\"label\":\"IS-07-02\",\"message\":\"$testmessage\",\"color\":\"$testcolour\"}" > badges/IS-07-02.json

        # IS-09-02
        case $($run_test suite IS-09-02 --selection all --host "${{ env.HOST_IP_ADDRESS }}" null --port 0 0 --version null v1.0 --output "results/${{ env.GITHUB_COMMIT }}-${{ env.BUILD_NAME }}-IS-09-02.json"  >> results/testoutput 2>&1; echo $?) in
        [0-1])  testmessage="Pass" && testcolour="brightgreen";;
        *)      testmessage="Fail" && testcolour="red";;
        esac
        printf "{\"schemaVersion\":1,\"label\":\"IS-09-02\",\"message\":\"$testmessage\",\"color\":\"$testcolour\"}" > badges/IS-09-02.json

        # Run Registry tests (leave Node running)
        ${root_dir}/build/nmos-cpp-registry "{\"pri\":0,\"http_port\":8080,\"domain\":\"local.\",\"logging_level\":-40}" > results/registryoutput 2>&1 &
        REGISTRY_PID=$!
        # short delay to give the Registry a chance to start up and the Node a chance to register before running the Registry test suite
        sleep 2
        # add a persistent Query WebSocket API subscription before running the Registry test suite
        curl "http://localhost:8080/x-nmos/query/v1.3/subscriptions" -H "Content-Type: application/json" -d "{\"max_update_rate_ms\": 100, \"resource_path\": \"/nodes\", \"params\": {\"label\": \"host1\"}, \"persist\": true, \"secure\": false}"

        # IS-04-02
        case $($run_test suite IS-04-02 --selection all --host "${{ env.HOST_IP_ADDRESS }}" "${{ env.HOST_IP_ADDRESS }}" --port 8080 8080 --version v1.3 v1.3 --output "results/${{ env.GITHUB_COMMIT }}-${{ env.BUILD_NAME }}-IS-04-02.json"  >> results/testoutput 2>&1; echo $?) in
        [0-1])  testmessage="Pass" && testcolour="brightgreen";;
        *)      testmessage="Fail" && testcolour="red";;
        esac
        printf "{\"schemaVersion\":1,\"label\":\"IS-04-02\",\"message\":\"$testmessage\",\"color\":\"$testcolour\"}" > badges/IS-04-02.json

        # IS-09-01
        case $($run_test suite IS-09-01 --selection all --host "${{ env.HOST_IP_ADDRESS }}" --port 8080 --version v1.0 --output "results/${{ env.GITHUB_COMMIT }}-${{ env.BUILD_NAME }}-IS-09-01.json"  >> results/testoutput 2>&1; echo $?) in
        [0-1])  testmessage="Pass" && testcolour="brightgreen";;
        *)      testmessage="Fail" && testcolour="red";;
        esac
        printf "{\"schemaVersion\":1,\"label\":\"IS-09-01\",\"message\":\"$testmessage\",\"color\":\"$testcolour\"}" > badges/IS-09-01.json

        # Stop Node and Registry
        kill $NODE_PID || echo "node not running"
        kill $REGISTRY_PID || echo "registry not running"

        if [[ "${{ env.DOCKER_TEST_SUITE }}" == "true" ]]; then
          docker stop nmos_testing
          docker rm nmos_testing
        fi
        if  [[ "${{ env.VAGRANT_TEST_SUITE }}" == "true" ]]; then
          vagrant scp :results/* results/
          vagrant destroy -f
        fi
        exit 0

    - name: upload to google drive
      if: github.ref == 'refs/heads/github-actions' && github.event_name == 'push'
      working-directory: ${{ runner.workspace }}
      shell: bash
      run: |
        root_dir_id=`${{ env.GDRIVE_GET_ID }} "${{ secrets.OUTPUT_FOLDER_ID }}" build/${{ env.BUILD_NAME }}`
        ${{ env.GDRIVE_PATH }} sync upload --keep-local --delete-extraneous nmos-testing/badges $root_dir_id

        function join_with {
          local sep=$1;
          shift
          printf "$d%s" "${@/#/$sep}"
        }

        export SHEET=https://docs.google.com/spreadsheets/d/${{ secrets.RESULTS_SHEET_ID }}
        python nmos-testing/utilities/run-test-suites/gsheetsImport/resultsImporter.py --credentials ${{ env.GDRIVE_CREDENTIALS }} --sheet "$SHEET" --insert `join_with " --json " nmos-testing/results/${{ env.GITHUB_COMMIT }}-*.json` || echo "upload failed"

    #- name: setup tmate
    #  uses: mxschmitt/action-tmate@v2
    #  if: matrix.os =='macos-latest'

    - uses: actions/upload-artifact@v1
      with:
        name: ${{ env.BUILD_NAME }}_badges
        path: ${{ runner.workspace }}/nmos-testing/badges

    - uses: actions/upload-artifact@v1
      with:
        name: ${{ env.BUILD_NAME }}_results
        path: ${{ runner.workspace }}/nmos-testing/results

  make_badges:
    if: github.ref == 'refs/heads/github-actions' && github.event_name == 'push'
    needs: build_and_test
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2

    - name: setup google drive
      run: |
        mkdir ${{ github.workspace }}/gdrive
        echo "${{ env.credentials }}" | openssl base64 -d -A -out ${{ github.workspace }}/gdrive/credentials.json
      env:
        credentials: ${{ secrets.GOOGLE_CREDENTIALS }}

    - name: download google drive ubuntu
      run: |
        curl -L https://github.com/gdrive-org/gdrive/releases/download/2.1.0/gdrive-linux-x64 -o ${{ github.workspace }}/gdrive/gdrive-linux-x64 -q
        chmod +x ${{ github.workspace }}/gdrive/gdrive-linux-x64
        echo "::set-env name=GDRIVE_PATH::${{ github.workspace }}/gdrive/gdrive-linux-x64" --config ${{ github.workspace }}/gdrive --service-account credentials.json
        echo "::set-env name=GDRIVE_GET_ID::${{ github.workspace }}/Sandbox/get_gdrive_id.sh"
        echo "::set-env name=GDRIVE_CREDENTIALS::${{ github.workspace }}/gdrive/credentials.json"

    - name: make badges
      run: |
        ${{ github.workspace }}/Sandbox/make_badges.sh ${{ secrets.OUTPUT_FOLDER_ID }} macos-latest
